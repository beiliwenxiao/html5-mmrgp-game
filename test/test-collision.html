<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¢°æ’æ£€æµ‹æµ‹è¯•</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
        }
        
        #container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: #4CAF50;
        }
        
        #canvas {
            display: block;
            margin: 20px auto;
            border: 2px solid #4CAF50;
            background: #2d5016;
            cursor: crosshair;
        }
        
        #info {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        
        .label {
            color: #888;
        }
        
        .value {
            color: #4CAF50;
            font-weight: bold;
        }
        
        #controls {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:active {
            background: #3d8b40;
        }
        
        #legend {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }
        
        .legend-color {
            width: 30px;
            height: 30px;
            margin-right: 10px;
            border: 2px solid #666;
        }
        
        .collision-indicator {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
        }
        
        .collision-yes {
            background: #f44336;
            color: white;
        }
        
        .collision-no {
            background: #4CAF50;
            color: white;
        }
    </style>
</head>
<body>
    <div id="container">
        <h1>ğŸ® ç¢°æ’æ£€æµ‹æµ‹è¯•</h1>
        
        <div id="info">
            <h3>å®æ—¶ä¿¡æ¯</h3>
            <div class="info-row">
                <span class="label">ç©å®¶ä½ç½®:</span>
                <span class="value" id="playerPos">-</span>
            </div>
            <div class="info-row">
                <span class="label">é¼ æ ‡ä½ç½®:</span>
                <span class="value" id="mousePos">-</span>
            </div>
            <div class="info-row">
                <span class="label">ç§»åŠ¨çŠ¶æ€:</span>
                <span class="value" id="moveStatus">-</span>
            </div>
            <div id="collisionStatus" class="collision-indicator collision-no">
                âœ“ æ— ç¢°æ’
            </div>
        </div>
        
        <div id="controls">
            <h3>æ§åˆ¶</h3>
            <p>ä½¿ç”¨ WASD æˆ–æ–¹å‘é”®ç§»åŠ¨ç©å®¶</p>
            <p>ç‚¹å‡»åœ°å›¾ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®</p>
            <button onclick="resetPlayer()">é‡ç½®ç©å®¶ä½ç½®</button>
            <button onclick="toggleObstacles()">åˆ‡æ¢éšœç¢ç‰©æ˜¾ç¤º</button>
            <button onclick="generateNewMap()">ç”Ÿæˆæ–°åœ°å›¾</button>
        </div>
        
        <canvas id="canvas" width="800" height="600"></canvas>
        
        <div id="legend">
            <h3>å›¾ä¾‹</h3>
            <div class="legend-item">
                <div class="legend-color" style="background: #4CAF50;"></div>
                <span>ç©å®¶ï¼ˆå¯ç§»åŠ¨ï¼‰</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #666;"></div>
                <span>éšœç¢ç‰©ï¼ˆä¸å¯é€šè¿‡ï¼‰</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #f44336;"></div>
                <span>åœ°å›¾è¾¹ç•Œï¼ˆä¸å¯é€šè¿‡ï¼‰</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255, 255, 0, 0.3);"></div>
                <span>ç›®æ ‡ä½ç½®</span>
            </div>
        </div>
    </div>

    <script type="module">
        import { MovementSystem } from './src/systems/MovementSystem.js';
        import { Entity } from './src/ecs/Entity.js';
        import { TransformComponent } from './src/ecs/components/TransformComponent.js';
        import { MovementComponent } from './src/ecs/components/MovementComponent.js';
        import { InputManager } from './src/core/InputManager.js';

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // åœ°å›¾é…ç½®
        const TILE_SIZE = 32;
        const MAP_WIDTH = 800;
        const MAP_HEIGHT = 600;
        const COLS = Math.ceil(MAP_WIDTH / TILE_SIZE);
        const ROWS = Math.ceil(MAP_HEIGHT / TILE_SIZE);
        
        // æ¸¸æˆçŠ¶æ€
        let showObstacles = true;
        let collisionMap = generateCollisionMap();
        let playerEntity = null;
        let movementSystem = null;
        let inputManager = null;
        let lastTime = 0;
        let targetPosition = null;
        
        // åˆå§‹åŒ–
        function init() {
            // åˆ›å»ºè¾“å…¥ç®¡ç†å™¨
            inputManager = new InputManager(canvas);
            
            // åˆ›å»ºç§»åŠ¨ç³»ç»Ÿ
            movementSystem = new MovementSystem({
                inputManager: inputManager,
                mapBounds: { minX: 0, minY: 0, maxX: MAP_WIDTH, maxY: MAP_HEIGHT },
                collisionMap: collisionMap,
                tileSize: TILE_SIZE
            });
            
            // åˆ›å»ºç©å®¶å®ä½“
            playerEntity = new Entity('player', 'player');
            playerEntity.addComponent(new TransformComponent(400, 300));
            playerEntity.addComponent(new MovementComponent({ speed: 150 }));
            
            movementSystem.setPlayerEntity(playerEntity);
            
            // ç›‘å¬é¼ æ ‡ç‚¹å‡»ä»¥æ˜¾ç¤ºç›®æ ‡ä½ç½®
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                targetPosition = { x, y };
                
                // 3ç§’åæ¸…é™¤ç›®æ ‡ä½ç½®æ˜¾ç¤º
                setTimeout(() => {
                    targetPosition = null;
                }, 3000);
            });
            
            // å¼€å§‹æ¸¸æˆå¾ªç¯
            requestAnimationFrame(gameLoop);
        }
        
        // ç”Ÿæˆç¢°æ’åœ°å›¾
        function generateCollisionMap() {
            const map = [];
            for (let y = 0; y < ROWS; y++) {
                const row = [];
                for (let x = 0; x < COLS; x++) {
                    // è¾¹ç•Œè®¾ä¸ºéšœç¢ç‰©
                    if (x === 0 || y === 0 || x === COLS - 1 || y === ROWS - 1) {
                        row.push(true);
                    }
                    // æ·»åŠ ä¸€äº›éšæœºéšœç¢ç‰©
                    else if (Math.random() < 0.15) {
                        row.push(true);
                    }
                    else {
                        row.push(false);
                    }
                }
                map.push(row);
            }
            return map;
        }
        
        // æ¸¸æˆå¾ªç¯
        function gameLoop(currentTime) {
            const deltaTime = lastTime ? (currentTime - lastTime) / 1000 : 0.016;
            lastTime = currentTime;
            
            // æ›´æ–°
            update(deltaTime);
            
            // æ¸²æŸ“
            render();
            
            // æ›´æ–°UI
            updateUI();
            
            requestAnimationFrame(gameLoop);
        }
        
        // æ›´æ–°
        function update(deltaTime) {
            movementSystem.update(deltaTime, [playerEntity]);
        }
        
        // æ¸²æŸ“
        function render() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.fillStyle = '#2d5016';
            ctx.fillRect(0, 0, MAP_WIDTH, MAP_HEIGHT);
            
            // ç»˜åˆ¶ç½‘æ ¼
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= MAP_WIDTH; x += TILE_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, MAP_HEIGHT);
                ctx.stroke();
            }
            for (let y = 0; y <= MAP_HEIGHT; y += TILE_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(MAP_WIDTH, y);
                ctx.stroke();
            }
            
            // ç»˜åˆ¶éšœç¢ç‰©
            if (showObstacles) {
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        if (collisionMap[y][x]) {
                            const isEdge = x === 0 || y === 0 || x === COLS - 1 || y === ROWS - 1;
                            ctx.fillStyle = isEdge ? '#f44336' : '#666';
                            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                            
                            // ç»˜åˆ¶è¾¹æ¡†
                            ctx.strokeStyle = isEdge ? '#d32f2f' : '#555';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        }
                    }
                }
            }
            
            // ç»˜åˆ¶ç›®æ ‡ä½ç½®
            if (targetPosition) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(targetPosition.x, targetPosition.y, 20, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'yellow';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(targetPosition.x, targetPosition.y, 20, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // ç»˜åˆ¶ç©å®¶
            const transform = playerEntity.getComponent('transform');
            const movement = playerEntity.getComponent('movement');
            
            // ç©å®¶åœ†å½¢
            ctx.fillStyle = '#4CAF50';
            ctx.beginPath();
            ctx.arc(transform.position.x, transform.position.y, 15, 0, Math.PI * 2);
            ctx.fill();
            
            // ç©å®¶è¾¹æ¡†
            ctx.strokeStyle = '#2E7D32';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(transform.position.x, transform.position.y, 15, 0, Math.PI * 2);
            ctx.stroke();
            
            // ç»˜åˆ¶æ–¹å‘æŒ‡ç¤ºå™¨
            if (movement.isMoving) {
                const angle = Math.atan2(movement.velocity.y, movement.velocity.x);
                const endX = transform.position.x + Math.cos(angle) * 25;
                const endY = transform.position.y + Math.sin(angle) * 25;
                
                ctx.strokeStyle = '#FFF';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(transform.position.x, transform.position.y);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }
            
            // ç»˜åˆ¶è·¯å¾„
            if (movement.path && movement.path.length > 0) {
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(transform.position.x, transform.position.y);
                for (const point of movement.path) {
                    ctx.lineTo(point.x, point.y);
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
        
        // æ›´æ–°UI
        function updateUI() {
            const transform = playerEntity.getComponent('transform');
            const movement = playerEntity.getComponent('movement');
            
            // ç©å®¶ä½ç½®
            document.getElementById('playerPos').textContent = 
                `(${Math.round(transform.position.x)}, ${Math.round(transform.position.y)})`;
            
            // é¼ æ ‡ä½ç½®
            const mousePos = inputManager.getMousePosition();
            document.getElementById('mousePos').textContent = 
                `(${Math.round(mousePos.x)}, ${Math.round(mousePos.y)})`;
            
            // ç§»åŠ¨çŠ¶æ€
            let status = 'å¾…æœº';
            if (movement.isMoving) {
                status = movement.movementType === 'keyboard' ? 'é”®ç›˜ç§»åŠ¨' : 'ç‚¹å‡»ç§»åŠ¨';
            }
            document.getElementById('moveStatus').textContent = status;
            
            // ç¢°æ’çŠ¶æ€
            const tileX = Math.floor(transform.position.x / TILE_SIZE);
            const tileY = Math.floor(transform.position.y / TILE_SIZE);
            const isOnCollision = collisionMap[tileY] && collisionMap[tileY][tileX];
            
            const collisionStatus = document.getElementById('collisionStatus');
            if (isOnCollision) {
                collisionStatus.className = 'collision-indicator collision-yes';
                collisionStatus.textContent = 'âš  åœ¨éšœç¢ç‰©ä¸Šï¼';
            } else {
                collisionStatus.className = 'collision-indicator collision-no';
                collisionStatus.textContent = 'âœ“ æ— ç¢°æ’';
            }
        }
        
        // å…¨å±€å‡½æ•°
        window.resetPlayer = function() {
            const transform = playerEntity.getComponent('transform');
            transform.setPosition(400, 300);
            const movement = playerEntity.getComponent('movement');
            movement.stop();
            targetPosition = null;
        };
        
        window.toggleObstacles = function() {
            showObstacles = !showObstacles;
        };
        
        window.generateNewMap = function() {
            collisionMap = generateCollisionMap();
            movementSystem.setCollisionMap(collisionMap, TILE_SIZE);
            resetPlayer();
        };
        
        // å¯åŠ¨
        init();
    </script>
</body>
</html>
