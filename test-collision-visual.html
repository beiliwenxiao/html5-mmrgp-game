<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ç¢°æ’æ£€æµ‹å¯è§†åŒ–æµ‹è¯•</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: Arial, sans-serif;
      background-color: #1a1a1a;
      color: #fff;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    h1 {
      text-align: center;
      color: #4CAF50;
    }
    
    .info {
      background-color: #2a2a2a;
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
    }
    
    .info h3 {
      margin-top: 0;
      color: #4CAF50;
    }
    
    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    
    button {
      padding: 10px 20px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
    }
    
    button:hover {
      background-color: #45a049;
    }
    
    button:disabled {
      background-color: #666;
      cursor: not-allowed;
    }
    
    #gameCanvas {
      display: block;
      margin: 0 auto;
      border: 2px solid #4CAF50;
      background-color: #2d5016;
      cursor: crosshair;
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
      margin-top: 20px;
    }
    
    .stat-item {
      background-color: #2a2a2a;
      padding: 10px;
      border-radius: 5px;
    }
    
    .stat-label {
      color: #888;
      font-size: 12px;
    }
    
    .stat-value {
      font-size: 18px;
      font-weight: bold;
      color: #4CAF50;
    }
    
    .legend {
      background-color: #2a2a2a;
      padding: 15px;
      border-radius: 5px;
      margin-top: 20px;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      margin: 5px 0;
    }
    
    .legend-color {
      width: 30px;
      height: 20px;
      margin-right: 10px;
      border: 1px solid #666;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ® ç¢°æ’æ£€æµ‹å¯è§†åŒ–æµ‹è¯•</h1>
    
    <div class="info">
      <h3>ğŸ“‹ æµ‹è¯•è¯´æ˜</h3>
      <p><strong>æ§åˆ¶æ–¹å¼ï¼š</strong></p>
      <ul>
        <li>ä½¿ç”¨ <strong>WASD</strong> æˆ– <strong>æ–¹å‘é”®</strong> ç§»åŠ¨è§’è‰²</li>
        <li>ç‚¹å‡»åœ°å›¾ä»»æ„ä½ç½®è¿›è¡Œç‚¹å‡»ç§»åŠ¨</li>
        <li>å°è¯•ç©¿è¿‡çº¢è‰²éšœç¢ç‰©ï¼ˆä¼šè¢«é˜»æ­¢ï¼‰</li>
        <li>å°è¯•ç§»åŠ¨åˆ°åœ°å›¾è¾¹ç•Œå¤–ï¼ˆä¼šè¢«é˜»æ­¢ï¼‰</li>
      </ul>
      <p><strong>æµ‹è¯•ç›®æ ‡ï¼š</strong></p>
      <ul>
        <li>âœ… åœ°å›¾è¾¹ç•Œæ£€æµ‹</li>
        <li>âœ… éšœç¢ç‰©ç¢°æ’æ£€æµ‹</li>
        <li>âœ… é”®ç›˜ç§»åŠ¨ç¢°æ’é˜»æ­¢</li>
        <li>âœ… ç‚¹å‡»ç§»åŠ¨ç¢°æ’é˜»æ­¢</li>
      </ul>
    </div>
    
    <div class="controls">
      <button id="resetBtn">ğŸ”„ é‡ç½®ä½ç½®</button>
      <button id="toggleObstaclesBtn">ğŸ‘ï¸ åˆ‡æ¢éšœç¢ç‰©æ˜¾ç¤º</button>
      <button id="toggleGridBtn">ğŸ“ åˆ‡æ¢ç½‘æ ¼æ˜¾ç¤º</button>
      <button id="addObstacleBtn">â• æ·»åŠ éšœç¢ç‰©</button>
    </div>
    
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div class="stats">
      <div class="stat-item">
        <div class="stat-label">è§’è‰²ä½ç½®</div>
        <div class="stat-value" id="positionStat">X: 0, Y: 0</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">ç§»åŠ¨é€Ÿåº¦</div>
        <div class="stat-value" id="velocityStat">0 px/s</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">ç§»åŠ¨æ¨¡å¼</div>
        <div class="stat-value" id="modeStat">æ— </div>
      </div>
      <div class="stat-item">
        <div class="stat-label">ç¢°æ’æ£€æµ‹</div>
        <div class="stat-value" id="collisionStat">æ­£å¸¸</div>
      </div>
    </div>
    
    <div class="legend">
      <h3>ğŸ¨ å›¾ä¾‹</h3>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #4CAF50;"></div>
        <span>ç©å®¶è§’è‰²ï¼ˆå¯ç§»åŠ¨ï¼‰</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #f44336;"></div>
        <span>éšœç¢ç‰©ï¼ˆä¸å¯ç©¿è¿‡ï¼‰</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #2196F3;"></div>
        <span>ç‚¹å‡»ç›®æ ‡ä½ç½®</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: rgba(255, 255, 255, 0.2);"></div>
        <span>ç½‘æ ¼çº¿ï¼ˆç“¦ç‰‡è¾¹ç•Œï¼‰</span>
      </div>
    </div>
  </div>

  <script type="module">
    import { Entity } from './src/ecs/Entity.js';
    import { TransformComponent } from './src/ecs/components/TransformComponent.js';
    import { MovementComponent } from './src/ecs/components/MovementComponent.js';
    import { SpriteComponent } from './src/ecs/components/SpriteComponent.js';
    import { MovementSystem } from './src/systems/MovementSystem.js';
    import { InputManager } from './src/core/InputManager.js';

    // è·å–Canvaså’Œä¸Šä¸‹æ–‡
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // é…ç½®
    const TILE_SIZE = 32;
    const MAP_WIDTH = 800;
    const MAP_HEIGHT = 600;
    const COLS = Math.ceil(MAP_WIDTH / TILE_SIZE);
    const ROWS = Math.ceil(MAP_HEIGHT / TILE_SIZE);

    // çŠ¶æ€
    let showObstacles = true;
    let showGrid = true;
    let addingObstacle = false;
    let clickTarget = null;
    let lastCollisionCheck = { canMove: true, x: 0, y: 0 };

    // åˆ›å»ºç¢°æ’åœ°å›¾
    function createCollisionMap() {
      const map = [];
      for (let y = 0; y < ROWS; y++) {
        const row = [];
        for (let x = 0; x < COLS; x++) {
          // è¾¹ç•Œè®¾ä¸ºéšœç¢ç‰©
          if (x === 0 || y === 0 || x === COLS - 1 || y === ROWS - 1) {
            row.push(true);
          }
          // æ·»åŠ ä¸€äº›é¢„è®¾éšœç¢ç‰©
          else if (
            (x >= 5 && x <= 7 && y >= 5 && y <= 10) ||
            (x >= 15 && x <= 17 && y >= 8 && y <= 12) ||
            (x >= 10 && x <= 12 && y >= 15 && y <= 17)
          ) {
            row.push(true);
          }
          else {
            row.push(false);
          }
        }
        map.push(row);
      }
      return map;
    }

    const collisionMap = createCollisionMap();

    // åˆ›å»ºè¾“å…¥ç®¡ç†å™¨
    const inputManager = new InputManager(canvas);

    // åˆ›å»ºç§»åŠ¨ç³»ç»Ÿ
    const movementSystem = new MovementSystem({
      inputManager,
      collisionMap,
      tileSize: TILE_SIZE,
      mapBounds: { minX: 0, minY: 0, maxX: MAP_WIDTH, maxY: MAP_HEIGHT }
    });

    // åˆ›å»ºç©å®¶å®ä½“
    const player = new Entity('player', 'player');
    player.addComponent(new TransformComponent(400, 300));
    player.addComponent(new MovementComponent({ speed: 150 }));
    player.addComponent(new SpriteComponent());

    movementSystem.setPlayerEntity(player);

    // æ¸²æŸ“å‡½æ•°
    function render() {
      // æ¸…ç©ºç”»å¸ƒ
      ctx.fillStyle = '#2d5016';
      ctx.fillRect(0, 0, MAP_WIDTH, MAP_HEIGHT);

      // ç»˜åˆ¶ç½‘æ ¼
      if (showGrid) {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        for (let x = 0; x <= COLS; x++) {
          ctx.beginPath();
          ctx.moveTo(x * TILE_SIZE, 0);
          ctx.lineTo(x * TILE_SIZE, MAP_HEIGHT);
          ctx.stroke();
        }
        for (let y = 0; y <= ROWS; y++) {
          ctx.beginPath();
          ctx.moveTo(0, y * TILE_SIZE);
          ctx.lineTo(MAP_WIDTH, y * TILE_SIZE);
          ctx.stroke();
        }
      }

      // ç»˜åˆ¶éšœç¢ç‰©
      if (showObstacles) {
        ctx.fillStyle = '#f44336';
        for (let y = 0; y < ROWS; y++) {
          for (let x = 0; x < COLS; x++) {
            if (collisionMap[y][x]) {
              ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
          }
        }
      }

      // ç»˜åˆ¶ç‚¹å‡»ç›®æ ‡
      if (clickTarget) {
        ctx.fillStyle = 'rgba(33, 150, 243, 0.5)';
        ctx.beginPath();
        ctx.arc(clickTarget.x, clickTarget.y, 10, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = '#2196F3';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(clickTarget.x, clickTarget.y, 15, 0, Math.PI * 2);
        ctx.stroke();
      }

      // ç»˜åˆ¶ç©å®¶
      const transform = player.getComponent('transform');
      const movement = player.getComponent('movement');
      
      // ç©å®¶ä¸»ä½“
      ctx.fillStyle = '#4CAF50';
      ctx.beginPath();
      ctx.arc(transform.position.x, transform.position.y, 12, 0, Math.PI * 2);
      ctx.fill();
      
      // ç©å®¶è¾¹æ¡†
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(transform.position.x, transform.position.y, 12, 0, Math.PI * 2);
      ctx.stroke();
      
      // ç»˜åˆ¶æ–¹å‘æŒ‡ç¤ºå™¨
      if (movement.isMoving) {
        const angle = Math.atan2(movement.velocity.y, movement.velocity.x);
        const dirX = transform.position.x + Math.cos(angle) * 20;
        const dirY = transform.position.y + Math.sin(angle) * 20;
        
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(transform.position.x, transform.position.y);
        ctx.lineTo(dirX, dirY);
        ctx.stroke();
      }

      // ç»˜åˆ¶ç¢°æ’æ£€æµ‹çŠ¶æ€
      if (!lastCollisionCheck.canMove) {
        ctx.fillStyle = 'rgba(244, 67, 54, 0.3)';
        ctx.beginPath();
        ctx.arc(lastCollisionCheck.x, lastCollisionCheck.y, 15, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    function updateStats() {
      const transform = player.getComponent('transform');
      const movement = player.getComponent('movement');
      
      document.getElementById('positionStat').textContent = 
        `X: ${Math.round(transform.position.x)}, Y: ${Math.round(transform.position.y)}`;
      
      const speed = Math.sqrt(movement.velocity.x ** 2 + movement.velocity.y ** 2);
      document.getElementById('velocityStat').textContent = `${Math.round(speed)} px/s`;
      
      const modeText = movement.isMoving ? 
        (movement.movementType === 'keyboard' ? 'é”®ç›˜' : 'ç‚¹å‡»') : 'é™æ­¢';
      document.getElementById('modeStat').textContent = modeText;
      
      const collisionText = lastCollisionCheck.canMove ? 'âœ… æ­£å¸¸' : 'âŒ ç¢°æ’';
      document.getElementById('collisionStat').textContent = collisionText;
    }

    // æ¸¸æˆå¾ªç¯
    let lastTime = performance.now();
    function gameLoop(currentTime) {
      const deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;

      // æ›´æ–°ç³»ç»Ÿ
      movementSystem.update(deltaTime, [player]);

      // æ£€æŸ¥å½“å‰ä½ç½®çš„ç¢°æ’çŠ¶æ€
      const transform = player.getComponent('transform');
      const movement = player.getComponent('movement');
      if (movement.isMoving) {
        const nextX = transform.position.x + movement.velocity.x * deltaTime;
        const nextY = transform.position.y + movement.velocity.y * deltaTime;
        lastCollisionCheck = {
          canMove: movementSystem.canMoveTo(nextX, nextY, player),
          x: nextX,
          y: nextY
        };
      } else {
        lastCollisionCheck.canMove = true;
      }

      // æ¸²æŸ“
      render();
      updateStats();

      requestAnimationFrame(gameLoop);
    }

    // æŒ‰é’®äº‹ä»¶
    document.getElementById('resetBtn').addEventListener('click', () => {
      const transform = player.getComponent('transform');
      transform.setPosition(400, 300);
      const movement = player.getComponent('movement');
      movement.stop();
      clickTarget = null;
    });

    document.getElementById('toggleObstaclesBtn').addEventListener('click', () => {
      showObstacles = !showObstacles;
    });

    document.getElementById('toggleGridBtn').addEventListener('click', () => {
      showGrid = !showGrid;
    });

    document.getElementById('addObstacleBtn').addEventListener('click', () => {
      addingObstacle = !addingObstacle;
      const btn = document.getElementById('addObstacleBtn');
      btn.textContent = addingObstacle ? 'âœ‹ å–æ¶ˆæ·»åŠ ' : 'â• æ·»åŠ éšœç¢ç‰©';
      btn.style.backgroundColor = addingObstacle ? '#ff9800' : '#4CAF50';
      canvas.style.cursor = addingObstacle ? 'cell' : 'crosshair';
    });

    // Canvasç‚¹å‡»äº‹ä»¶
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (addingObstacle) {
        // æ·»åŠ éšœç¢ç‰©
        const tileX = Math.floor(x / TILE_SIZE);
        const tileY = Math.floor(y / TILE_SIZE);
        if (tileX >= 0 && tileX < COLS && tileY >= 0 && tileY < ROWS) {
          collisionMap[tileY][tileX] = !collisionMap[tileY][tileX];
        }
      } else {
        // è®¾ç½®ç‚¹å‡»ç›®æ ‡
        clickTarget = { x, y };
        // ç‚¹å‡»ç›®æ ‡ä¼šåœ¨ä¸€æ®µæ—¶é—´åæ¶ˆå¤±
        setTimeout(() => {
          if (clickTarget && clickTarget.x === x && clickTarget.y === y) {
            clickTarget = null;
          }
        }, 2000);
      }
    });

    // å¯åŠ¨æ¸¸æˆå¾ªç¯
    console.log('ç¢°æ’æ£€æµ‹å¯è§†åŒ–æµ‹è¯•å¯åŠ¨');
    gameLoop(performance.now());
  </script>
</body>
</html>
